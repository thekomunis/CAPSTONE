# -*- coding: utf-8 -*-
"""Modelling update

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1R7L6rI5y-V45eDM1onyTda1duKtxi9CD

# **1. Import Library**
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import xgboost as xgb
import lightgbm as lgb


from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, OneHotEncoder, OrdinalEncoder, LabelEncoder
from sklearn.ensemble import RandomForestClassifier
from xgboost import XGBClassifier
from lightgbm import LGBMClassifier
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score
from sklearn.model_selection import cross_val_score, StratifiedKFold
from sklearn.model_selection import GridSearchCV, RandomizedSearchCV
from sklearn.feature_selection import chi2

"""# **2. Data Understanding**

### 2.1 Data Loading
"""

file_path = "cat_disease.csv"
disease_df = pd.read_csv(file_path)
disease_df = disease_df.drop(columns=['Animal_Type'])
disease_df.head()

"""# **3. Exploratory Data Analysis (EDA)**"""

#Meninjau jumlah baris dan kolom dataset
jumlah_baris, jumlah_kolom = disease_df.shape

print(f"Jumlah baris (rows): {jumlah_baris}")
print(f"Jumlah kolom (columns): {jumlah_kolom}")

#Menampilkan informasi dataset
disease_df.info()

#Memeriksa Missing Values pada dataset
disease_df.isnull().sum()

## ringkasan statistik dataset
describ = disease_df.describe()
describ

#menampilkan jumlah label kolom Disease
print(disease_df['Disease_Prediction'].value_counts())

#Visualisasi data numerik menggunakan histogram dan boxplot
numerical_cols = ['Age', 'Weight', 'Heart_Rate']

fig_num, axes = plt.subplots(nrows=3, ncols=2, figsize=(12, 12))
fig_num.suptitle("Visualisasi Data Numerikal", fontsize=16)

for i, col in enumerate(numerical_cols):
    # Histogram
    sns.histplot(disease_df[col], kde=True, ax=axes[i][0], color='skyblue')
    axes[i][0].set_title(f'Histogram of {col}')

    # Boxplot
    sns.boxplot(x=disease_df[col], ax=axes[i][1], color='lightgreen')
    axes[i][1].set_title(f'Boxplot of {col}')

plt.tight_layout(rect=[0, 0, 1, 0.96])
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

# Pilih kolom kategorikal
categorical_cols = disease_df.select_dtypes(include='object').columns.tolist()

# Atur ukuran subplot dinamis
ncols = 2
nrows = (len(categorical_cols) + 1) // ncols
fig_cat, axes = plt.subplots(nrows=nrows, ncols=ncols, figsize=(18, nrows * 4))
fig_cat.suptitle("Visualisasi Data Kategorikal", fontsize=20)

# Flatten axes supaya bisa diakses seperti list
axes = axes.flatten()

for i, col in enumerate(categorical_cols):
    # Ambil sumbu saat ini
    ax = axes[i]

    # Ambil top 20 kategori (opsional, bisa disesuaikan)
    top_categories = disease_df[col].value_counts().nlargest(20).index

    # Plot barplot untuk top kategori
    sns.countplot(data=disease_df[disease_df[col].isin(top_categories)],
                  x=col, order=top_categories, ax=ax, palette="Set2")

    ax.set_title(f'Count Plot of {col}', fontsize=14)
    ax.tick_params(axis='x', rotation=90, labelsize=10)
    ax.set_xlabel(col, fontsize=12)
    ax.set_ylabel("Count", fontsize=12)

# Hilangkan axes kosong jika jumlah kolom ganjil
for j in range(i + 1, len(axes)):
    fig_cat.delaxes(axes[j])

plt.tight_layout(rect=[0, 0, 1, 0.95])
plt.show()

# Pairplot untuk hubungan antar variabel numerikal
sns.pairplot(disease_df.select_dtypes(include=[np.number]))
plt.suptitle("Pairplot Antar Variabel Numerik", y=1.02)
plt.show()

"""## **4. Data Preparation**"""

pd.set_option('future.no_silent_downcasting', True)

# Gender Mapping
gender_mapping = {
    'Male': 0,
    'Female': 1
}
disease_df['Gender'] = disease_df['Gender'].replace(gender_mapping).infer_objects(copy=False)

# Yes No Mapping
yes_no_mapping = {
    'No': 0,
    'Yes': 1
}
disease_df['Appetite_Loss'] = disease_df['Appetite_Loss'].replace(yes_no_mapping).infer_objects(copy=False)
disease_df['Vomiting'] = disease_df['Vomiting'].replace(yes_no_mapping).infer_objects(copy=False)
disease_df['Diarrhea'] = disease_df['Diarrhea'].replace(yes_no_mapping).infer_objects(copy=False)
disease_df['Coughing'] = disease_df['Coughing'].replace(yes_no_mapping).infer_objects(copy=False)
disease_df['Labored_Breathing'] = disease_df['Labored_Breathing'].replace(yes_no_mapping).infer_objects(copy=False)
disease_df['Lameness'] = disease_df['Lameness'].replace(yes_no_mapping).infer_objects(copy=False)
disease_df['Skin_Lesions'] = disease_df['Skin_Lesions'].replace(yes_no_mapping).infer_objects(copy=False)
disease_df['Nasal_Discharge'] = disease_df['Nasal_Discharge'].replace(yes_no_mapping).infer_objects(copy=False)
disease_df['Eye_Discharge'] = disease_df['Eye_Discharge'].replace(yes_no_mapping).infer_objects(copy=False)

label_encoders = {}

# List kolom yang perlu diencode
categorical_cols = ['Breed', 'Symptom_1', 'Symptom_2', 'Symptom_3', 'Symptom_4',
                    'Duration', 'Body_Temperature', 'Disease_Prediction']

# Encode setiap kolom kategorikal ke numerik
for col in categorical_cols:
    le = LabelEncoder()
    disease_df[col] = le.fit_transform(disease_df[col])
    label_encoders[col] = le  # Simpan encoder untuk setiap kolom

disease_df.head()

disease_df.info()

print(disease_df['Disease_Prediction'].value_counts())

label_counts = disease_df['Disease_Prediction'].value_counts()
valid_labels = label_counts[label_counts >= 9].index

filtered_df = disease_df[disease_df['Disease_Prediction'].isin(valid_labels)]

X = filtered_df.drop(columns=['Disease_Prediction'])
y = filtered_df['Disease_Prediction']

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42, stratify=y
)

"""## **5. Modelling & Evaluation**

### 5.1 Latih Model dengan Random Forest
"""

from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score

model = RandomForestClassifier(n_estimators=50, random_state=42, max_depth=15)
model.fit(X_train, y_train)

from sklearn.metrics import accuracy_score, f1_score, ConfusionMatrixDisplay
# Evaluasi
y_train_pred = model.predict(X_train)
y_test_pred = model.predict(X_test)

rf_train_acc = accuracy_score(y_train, y_train_pred)
rf_test_acc = accuracy_score(y_test, y_test_pred)
rf_train_f1 = f1_score(y_train, y_train_pred, average='weighted')
rf_test_f1 = f1_score(y_test, y_test_pred, average='weighted')

print(f"Random Forest - Training Accuracy: {rf_train_acc:.2%}, F1-Score: {rf_train_f1:.2%}")
print(f"Random Forest - Testing Accuracy: {rf_test_acc:.2%}, F1-Score: {rf_test_f1:.2%}")

"""### 5.2 Latih Model dengan XG Boost"""

from xgboost import XGBClassifier
from sklearn.metrics import accuracy_score, f1_score
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split

# 1. Label Encoding (jika target tidak mulai dari 0)
le = LabelEncoder()
y_encoded = le.fit_transform(y)

# 2. Split data
X_train, X_test, y_train, y_test = train_test_split(
    X, y_encoded, test_size=0.2, stratify=y_encoded, random_state=42)

# 3. Inisialisasi model XGBoost
xgb_model = XGBClassifier(
    objective='multi:softmax',
    num_class=len(le.classes_),
    eval_metric='mlogloss',
    use_label_encoder=False,
    random_state=42
)

# 4. Latih model
xgb_model.fit(X_train, y_train)

# 5. Evaluasi model
y_train_pred = xgb_model.predict(X_train)
y_test_pred = xgb_model.predict(X_test)

xgb_train_acc = accuracy_score(y_train, y_train_pred)
xgb_test_acc = accuracy_score(y_test, y_test_pred)
xgb_train_f1 = f1_score(y_train, y_train_pred, average='weighted')
xgb_test_f1 = f1_score(y_test, y_test_pred, average='weighted')

# 6. Print hasil evaluasi
print(f"XGBoost - Training Accuracy: {xgb_train_acc:.2%}, F1-Score: {xgb_train_f1:.2%}")
print(f"XGBoost - Testing Accuracy: {xgb_test_acc:.2%}, F1-Score: {xgb_test_f1:.2%}")

"""## **6. Tunning**"""

from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import RandomizedSearchCV

rf_param_grid = {
    'n_estimators': [100, 200, 300],
    'max_depth': [5, 10, 15],
    'min_samples_split': [2, 5, 10],
    'min_samples_leaf': [1, 2, 4]
}

rf = RandomForestClassifier(random_state=42)
rf_search = RandomizedSearchCV(rf, rf_param_grid, n_iter=10, cv=3, scoring='accuracy', random_state=42, n_jobs=-1)
rf_search.fit(X_train, y_train)

print("Best RF Params:", rf_search.best_params_)
print("Best RF Score:", rf_search.best_score_)

from xgboost import XGBClassifier

xgb_param_grid = {
    'n_estimators': [100, 200],
    'max_depth': [3, 5, 7],
    'learning_rate': [0.01, 0.1, 0.2],
    'subsample': [0.6, 0.8, 1.0]
}

xgb = XGBClassifier(random_state=42, use_label_encoder=False, eval_metric='mlogloss')
xgb_search = RandomizedSearchCV(xgb, xgb_param_grid, n_iter=10, cv=3, scoring='accuracy', random_state=42, n_jobs=-1)
xgb_search.fit(X_train, y_train)

print("Best XGB Params:", xgb_search.best_params_)
print("Best XGB Score:", xgb_search.best_score_)

best_model = rf_search.best_estimator_  # atau xgb_search.best_estimator_, dst.
best_model.predict(X_test)

"""## **Testing**"""

# Ambil baris pertama dari X_test sebagai input
input_df = X_test.iloc[[0]]
print("Data input:\n", input_df)

# Prediksi
prediksi = best_model.predict(input_df)
print("Hasil prediksi:", prediksi[0])

"""## **Konversi Model**

Menyimpan dan Memuat Model (Deployment ke Backend)
"""

import joblib

# Simpan model ke file
joblib.dump(best_model, 'best_model.pkl')

# Jika menggunakan scaler juga simpan
joblib.dump(scaler, 'scaler.pkl')

# Kemudian untuk load ulang:
model = joblib.load('best_model.pkl')
scaler = joblib.load('scaler.pkl')

"""Mengkonversi untuk Web Deployment (Flask, FastAPI)"""

from flask import Flask, request, jsonify
import joblib
import pandas as pd

model = joblib.load('best_model.pkl')
scaler = joblib.load('scaler.pkl')

app = Flask(__name__)

@app.route('/predict', methods=['POST'])
def predict():
    input_data = request.json
    input_df = pd.DataFrame([input_data])
    input_scaled = scaler.transform(input_df)
    prediction = model.predict(input_scaled)[0]
    return jsonify({'prediction': int(prediction)})

if __name__ == '__main__':
    app.run()